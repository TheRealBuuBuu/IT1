Tabellnøkler
============
**I Norge er det 730 menn som heter Jan Johansen. Dersom vi lager et databasesystem for å holde oversikt over personer, hvordan skal vi skille alle disse Jan Johansen-ene fra hverandre?**

Vi trenger et eller annet som er unikt for hver enkelt person, og en vanlig måte å gjøre dette på er å dele ut unike personnummer til hvert enkelt individ. Det er én og bare én person som kan ha et gitt personnummer. Dersom vi søker etter individet med personnummeret 123456 78901 vet vi at det bare kan være én enkelt person.

I tabellene i en SQL-database ønsker vi ofte at verdiene i minst en kolonne i tabellen er unik for hver enkelt rad. En tabell med personinformasjon kan for eksempel se slik ut:

| Personnummer      | Fornavn  | Etternavn
| ----------------- |--------- | ---------
| 123456 78901      | Jan      | Johansen
| 345678 90123      | Jan      | Johansen
| 567890 12345      | Jan      | Johansen
| 789012 34567      | Jan      | Johansen
| 901234 56789      | Jan      | Johansen

Vi kaller kolonner som har unike verdier for en nøkkel. Noen ganger kan en tabell ha mer enn en kolonne med unike verdier. Vi sier da at vi har flere **kandidatnøkler**, de er kandidater til å bli en **primærnøkkel** i tabellen.
    
 Ofte er det sånn at vi ikke har noen kolonne som naturlig kan brukes som primærnøkkel, fordi vi ikke er sikre på at verdiene i kolonna alltid vil være unike for hver enkelt rad i tabellen. Da er det vanlig å lage en kolonne som inneholder heltallverdier, hvor vi sørger for at vi aldri bruker samme heltall flere ganger. Ofte kalles slike kolonner for `ID` eller noe liknende.
 
 Vi henter fram lagerbeholdningstabellen fra hurtigmatrestauranten vår igjen:
 
| Varenavn               | Beholdning |
| ---------------------- |----------: |
| Hamburger 150 g        | 90         |
| Hamburger 200 g        | 447        |
| Tomatskiver            | 1232       |
| Sylteagurkskiver       | 987        |
| Cheddarostskiver       | 376        |
| Jarlsbergostskiver     | 83         |
| Burgerbrød             | 1995       |

Når vi laget denne tabellen gikk vi ut ifra at varenavnet alltid ville være unikt, men er det lurt å anta dette? Kanskje bytter vi leverandør av 150 grams hamburgere en gang i framtida, og ønsker å skille gamle og nye varer fra hverandre? Det kan i alle fall være lurt å ta høyde for endringer i framtida, så derfor legger vi inn en ny ID-kolonne i tabellen vår som er unik for hver enkelt vare i tabellen:
  
VareID | Varenavn               | Beholdning |
-----: | ---------------------- |----------: |
1      | Hamburger 150 g        | 90         |
2      | Hamburger 200 g        | 447        |
3      | Tomatskiver            | 1232       |
4      | Sylteagurkskiver       | 987        |
5      | Cheddarostskiver       | 376        |
6      | Jarlsbergostskiver     | 83         |
7      | Burgerbrød             | 1995       |

Nå ser det kanskje ut som om vi bare har laget radnummer i tabellen vår, slik vi for eksempel har i regneark. Sånn er det ikke i SQL. I en SQL-tabell har ikke radene noen spesiell rekkefølge, så vi kan ikke be om å få en spesiell rad i tabellen. Ønsker vi å referere til en spesiell rad i tabellen må vi selv sørge for å lage en primærnøkkel i tabellen.

Ulike SQL-systemer har forskjellige måter å opprette primærnøkler på, så du må alltid sjekke i dokumentasjonen for systemet du jobber med for å finne ut hvordan det skal gjøres. Her kan du se hvordan det gjøres i MySQL og i SQLite:

**MySQL**
```SQL
CREATE TABLE Lagerbeholdning (
  VareID INTEGER NOT NULL AUTO_INCREMENT,
  Varenavn CHAR(255),
  Beholdning INTEGER,
  PRIMARY KEY(VareID)
);
```

**SQLite**
```SQL
CREATE TABLE Lagerbeholdning (
  VareID INTEGER PRIMARY KEY,
  Varenavn CHAR(255),
  Beholdning INTEGER
);
```

Når vi har laget denne tabellen trenger vi ikke å lage noen verdi for `VareID` selv, det gjøres helt automatisk. Vi kan sette inn nye rader i tabellen slik:

```SQL
INSERT INTO Lagerbeholdning (Varenavn, Beholdning) VALUES ('Jalapeño', 1500);
INSERT INTO Lagerbeholdning (Varenavn, Beholdning) VALUES ('Løkringer', 2930);
```
